package ez.webjooq

import org.jooq.*
import org.jooq.impl.DSL
import org.jooq.types.*

/**
 * wrap jooq dao for web. web api code generated by openapi has own schema,
 * so we should convert openapi Pojos and jooq Pojos to each other when calling dao apis
 */
@Suppress("MemberVisibilityCanBePrivate")
open class WebjooqDao<R : UpdatableRecord<R>, OuterPojo : Any, InnerPojo : Any, OuterId, InnerId, D : DAO<R, InnerPojo, InnerId>>(
  val dao: D,
  val pojoClass: Class<OuterPojo>,
  val idToInner: (OuterId) -> InnerId
) {
  /**
   * function to convert outer pojo to inner pojo
   */
  var outerPojoToInner: (OuterPojo) -> InnerPojo = {
    val record = dao.table.newRecord()
    record.from(it)
    record.into(dao.type)
  }

  /**
   * function to convert inner pojo to outer pojo
   */
  var innerPojoToOuter: (InnerPojo) -> OuterPojo = {
    val record = dao.table.newRecord()
    record.from(it)
    record.into(pojoClass)
  }

  /**
   * insert a record
   */
  fun insert(pojo: OuterPojo): OuterPojo {
    val innerPojo = outerPojoToInner(pojo)
    dao.insert(innerPojo)
    return innerPojoToOuter(innerPojo)
  }

  /**
   * insert multiple records
   */
  fun insert(pojoList: Collection<OuterPojo>): MutableList<OuterPojo> {
    val innerPojoList = pojoList.map(outerPojoToInner)
    dao.insert(innerPojoList)
    return innerPojoList.mapTo(mutableListOf(), innerPojoToOuter)
  }

  /**
   * delete records by ids
   */
  fun deleteById(idList: Collection<OuterId>) {
    val innerPKList = idList.map(idToInner)
    dao.deleteById(innerPKList)
  }

  /**
   * delete records by ids
   */
  fun deleteById(vararg ids: OuterId) {
    deleteById(ids.asList())
  }

  /**
   * delete records by pojos(convert pojo to where condition)
   */
  fun delete(pojoList: Collection<OuterPojo>) {
    dao.delete(pojoList.map(outerPojoToInner))
  }

  /**
   * delete records by pojos(convert pojo to where condition)
   */
  fun delete(vararg pojos: OuterPojo) {
    delete(pojos.asList())
  }

  /**
   * update records by pojos(auto identify pk field from pojo)
   */
  fun update(pojoList: Collection<OuterPojo>): MutableList<OuterPojo> {
    val innerPojoList = pojoList.map(outerPojoToInner)
    dao.update(innerPojoList)
    return innerPojoList.mapTo(mutableListOf(), innerPojoToOuter)
  }

  /**
   * update records by pojos(auto identify pk field from pojo)
   */
  fun update(vararg pojos: OuterPojo): MutableList<OuterPojo> {
    return update(pojos.asList())
  }

  /**
   * get table primary key fields
   */
  private fun pk(): Array<out TableField<R, *>> =
    dao.table.primaryKey?.fieldsArray
      ?: throw IllegalStateException("No primary key defined for table `${dao.table.name}`")

  @Suppress("UNCHECKED_CAST")
  private fun Array<out TableField<R, *>>.eq(id: InnerId): Condition {
    return if (size == 1) (this[0] as Field<Any?>).equal(this[0].dataType.convert(id))
    else DSL.row(*this).equal(id as Record)
  }

  @Suppress("UNCHECKED_CAST")
  private fun Array<out TableField<R, *>>.`in`(ids: Collection<InnerId>): Condition {
    return if (size == 1) (this[0] as Field<Any?>).`in`(ids.map {
      this[0].dataType.convert(it)
    })
    else DSL.row(*this).`in`(DSL.row(ids))
  }

  /**
   * update record by id
   * @return the updated record
   */
  fun updateById(id: OuterId, pojo: OuterPojo): OuterPojo? {
    val innerId = idToInner(id)
    val dsl = dao.configuration().dsl()
    val record = dsl.selectFrom(dao.table)
      .where(pk().eq(innerId))
      .fetchOne()
    if (record != null) {
      val innerPojo = outerPojoToInner(pojo)
      record.from(innerPojo)
      record.update()
      return innerPojoToOuter(innerPojo)
    } else {
      return null
    }
  }

  /**
   * find record by id
   */
  fun findById(id: OuterId): OuterPojo? {
    val innerId = idToInner(id)
    val innerPojo = dao.findById(innerId)
    return if (innerPojo != null) innerPojoToOuter(innerPojo) else null
  }

  /**
   * fetch records by ids
   */
  fun fetchById(ids: Collection<OuterId>): MutableList<OuterPojo> {
    val innerIds = ids.map { idToInner(it) }
    val dsl = dao.configuration().dsl()
    return dsl.selectFrom(dao.table).where(pk().`in`(innerIds)).fetchInto(pojoClass)
  }

  /**
   * run [findAction] to find a record and convert it to [OuterPojo]
   */
  fun find(findAction: (D) -> InnerPojo?): OuterPojo? {
    val innerPojo = findAction(dao)
    return if (innerPojo == null) null else innerPojoToOuter(innerPojo)
  }

  /**
   * run [fetchAction] to fetch records and convert them to [OuterPojo]
   */
  fun fetch(fetchAction: (D) -> Collection<InnerPojo>): MutableList<OuterPojo> {
    val innerPojos = fetchAction(dao)
    return innerPojos.mapTo(mutableListOf(), innerPojoToOuter)
  }
}

/**
 * convert [DAO] with [UByte] pk to [WebjooqDao]
 */
@JvmName("wrapForUByte")
inline fun <R : UpdatableRecord<R>, OuterPojo : Any, InnerPojo : Any, reified D : DAO<R, InnerPojo, UByte>> D.wrap(
  pojoClass: Class<OuterPojo>
) = WebjooqDao(this, pojoClass) { it: Byte -> Unsigned.ubyte(it) }

/**
 * convert [DAO] with [UShort] pk to [WebjooqDao]
 */
@JvmName("wrapForUShort")
inline fun <R : UpdatableRecord<R>, OuterPojo : Any, InnerPojo : Any, reified D : DAO<R, InnerPojo, UShort>> D.wrap(
  pojoClass: Class<OuterPojo>
) = WebjooqDao(this, pojoClass) { it: Short -> Unsigned.ushort(it) }

/**
 * convert [DAO] with [UInteger] pk to [WebjooqDao]
 */
@JvmName("wrapForUInt")
inline fun <R : UpdatableRecord<R>, OuterPojo : Any, InnerPojo : Any, reified D : DAO<R, InnerPojo, UInteger>> D.wrap(
  pojoClass: Class<OuterPojo>
) = WebjooqDao(this, pojoClass) { it: Int -> Unsigned.uint(it) }

/**
 * convert [DAO] with [ULong] pk to [WebjooqDao]
 */
@JvmName("wrapForULong")
inline fun <R : UpdatableRecord<R>, OuterPojo : Any, InnerPojo : Any, reified D : DAO<R, InnerPojo, ULong>> D.wrap(
  pojoClass: Class<OuterPojo>
) = WebjooqDao(this, pojoClass) { it: Long -> Unsigned.ulong(it) }

/**
 * convert [DAO] with non-unsigned type pk to [WebjooqDao]
 */
inline fun <R : UpdatableRecord<R>, OuterPojo : Any, InnerPojo : Any, PK, reified D : DAO<R, InnerPojo, PK>> D.wrap(
  pojoClass: Class<OuterPojo>
) = WebjooqDao(this, pojoClass) { it: PK -> it }

/**
 * convert [DAO] with non-unsigned type pk to [WebjooqDao]
 */
inline fun <R : UpdatableRecord<R>, OuterPojo : Any, InnerPojo : Any, OuterId, PK, reified D : DAO<R, InnerPojo, PK>> D.wrap(
  pojoClass: Class<OuterPojo>, noinline idToInner: (OuterId) -> PK
) = WebjooqDao(this, pojoClass, idToInner)